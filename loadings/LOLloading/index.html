<canvas id="canvas" width="1280" height="720"></canvas>
<script type="text/javascript">
    const canvas = document.getElementById('canvas');
    const width = 1280;
    const height = 720;
    const ctx = canvas.getContext('2d');


    const colorBackground = "rgb(1,10,19)";
    const colorBorderLight = "rgb(100,97,79)";
    const colorBorderDark = "rgb(33,32,19)";
    const colorDash= "rgb(26,32,35)";
    const colorDashBig= "rgb(9,18,24)";

    const startTime = new Date();

    const c1_delay = 20000;

    const c2_delay = 120000;
    const c2_num = 256;
    const c2_r1 = height * 3 / 8 - 30;
    const c2_r2 = height * 3 / 8 - 10;

    const c3_delay = 600000;
    const c3_num = 256;
    const c3_r1 = width * 2 / 5;
    const c3_r2 = width;

    const c4_delay = 1200000;
    const c4_num = 24;
    const c4_rc = width * 2 / 5;
    const c4_w = 7;

    function draw(){
        const timeFlow = new Date().getTime() - startTime.getTime();

        //绘制背景
        ctx.fillStyle = colorBackground;
        ctx.fillRect(0,0,width,height);

        //绘制虚线组成的内圆
        let c2_p = (timeFlow % c2_delay) / c2_delay;
        ctx.beginPath();
        for(let i = 0; i<c2_num; i++){
            let o = 2*Math.PI * (i / c2_num + c2_p);
            ctx.moveTo(width/2 + c2_r1 * Math.cos(o), height/2 + c2_r1 * Math.sin(o))
            ctx.lineTo(width/2 + c2_r2 * Math.cos(o), height/2 + c2_r2 * Math.sin(o))
        }
        ctx.closePath();
        ctx.strokeStyle = colorDash;
        ctx.lineWidth = 2;
        ctx.stroke();

        //绘制虚线组成的大外圆
        let c3_p = (timeFlow % c3_delay) / c3_delay;
        ctx.beginPath();
        for(let i = 0; i<c3_num; i++){
            let o = 2*Math.PI * (i / c3_num - c3_p);
            ctx.moveTo(width/2 + c3_r1 * Math.cos(o), height/2 + c3_r1 * Math.sin(o))
            ctx.lineTo(width/2 + c3_r2 * Math.cos(o), height/2 + c3_r2 * Math.sin(o))
        }
        ctx.closePath();

        let bgLineGradient = ctx.createRadialGradient(width/2,height/2,c3_r1,width/2,height/2,width / 2 + 50);
        bgLineGradient.addColorStop(0.3,colorDashBig);
        bgLineGradient.addColorStop(1,"rgba(9,18,24,0)");

        ctx.strokeStyle = bgLineGradient;
        ctx.lineWidth = 2;
        ctx.stroke();



        
        let c1_p = (timeFlow % c1_delay) / c1_delay;
        let c1_x = width/2 + height * 3 / 8 * Math.cos(2*Math.PI*c1_p);
        let c1_y = height/2 + height * 3 / 8 * Math.sin(2*Math.PI*c1_p);

        let lineGradient = ctx.createLinearGradient(c1_x,c1_y,
            width - c1_x,height - c1_y);
        lineGradient.addColorStop(0,colorBorderLight);
        lineGradient.addColorStop(.025,colorBorderDark);
        lineGradient.addColorStop(.975,colorBorderDark);
        lineGradient.addColorStop(1,colorBorderLight);

        //小方块
        let c4_p = (timeFlow % c4_delay) / c4_delay;
        ctx.beginPath();
        for(let i = 0; i<c4_num; i++){
            let o = 2*Math.PI * (i / c4_num - c4_p);
            let x1 = width/2 + (c4_rc - c4_w*Math.sqrt(2)) * Math.cos(o);
            let y1 = height/2 + (c4_rc - c4_w*Math.sqrt(2)) * Math.sin(o);
            let x2 = width/2 + c4_rc * Math.cos(o);
            let y2 = height/2 + c4_rc * Math.sin(o);
            ctx.moveTo(x1, y1);
            ctx.lineTo(x1 + c4_w*Math.cos(o - Math.PI/4), y1 + c4_w*Math.sin(o - Math.PI/4));
            ctx.lineTo(x2, y2);
            ctx.lineTo(x1 + c4_w*Math.cos(o + Math.PI/4), y1 + c4_w*Math.sin(o + Math.PI/4));
            ctx.lineTo(x1, y1);
        }
        ctx.closePath();

        ctx.strokeStyle = lineGradient;
        ctx.lineWidth = 1.5;
        ctx.stroke();
        
        //两边夹线
        ctx.beginPath();
        ctx.moveTo(0, height / 2);
        ctx.lineTo(width / 2 - height * 3 / 8 + 0.5, height / 2  + 0.5);

        ctx.moveTo(width / 2 + height * 3 / 8  + 0.5, height / 2 + 0.5);
        ctx.lineTo(width, height / 2);
        ctx.closePath();
        ctx.strokeStyle = lineGradient;
        ctx.lineWidth = 0.5;
        ctx.stroke();

        //绘制圆
        // ctx.move(width/2,height/2);
        ctx.beginPath();
        ctx.arc(width/2, height/2, height * 3 / 8, 0, 2*Math.PI)
        ctx.closePath();

        ctx.strokeStyle = lineGradient;
        ctx.lineWidth = 3;
        ctx.stroke();

        requestAnimationFrame(draw)
    }


    requestAnimationFrame(draw)
</script>
